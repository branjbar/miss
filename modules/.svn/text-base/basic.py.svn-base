'''
Created on Jan 30, 2014

@author: Bijan

This file includes basic procedures for connecting to SQL database on the server, 
and also simple comparison modules for assigning scores to different matches. 

'''


def do_connect(type = 'LOCAL'):
    global db
    ''' 
    connects to either the Swarmlab-srv01 (SRV) server, or the localhost (LOCAL). 
    
    Instructions for connecting to server: 
        First, you should setup an SSH tunel using:
        ssh bijan@swarmlab-srv01 -L 9990:localhost:3306
        Please not that you cannot connect from outside the unimass network to this server
    '''
    #!/usr/bin/python
    import MySQLdb
    if type == "SRV":
        db = MySQLdb.connect(host="127.0.0.1", 
                             user="bijan", 
                              passwd="bhic", 
                              db="links_based")
        db.autocommit(True)
        return db

    if type == "LOCAL":
        db = MySQLdb.connect(host="127.0.0.1", 
                             user="root", 
                              passwd="", 
                              db="links_based")
        db.autocommit(True)
        return db
    print("ERROR: Choose the right database source : SRV or Local")


def run_query(db, query):
    ''' (string) -> (query)
    gets a SQL query and returns the list of results
    '''
    
    cur = db.cursor() 
    cur.execute(query)
    return cur


def string_compare(str1, str2, method = 'JARO'):
    ''' (string, string, string) -> double
    returns the similarity of str1 and str2 according to the method: LEV or JARO
    
    '''
    import jellyfish
    
    if method == "LEV":
        # computes Levnenshtein distance which is an integer larger or equal to zero 
        return jellyfish.levenshtein_distance(str1, str2)
    
     
    if method == "JARO":
        # computes Jaro Winkler measure which is always between 0 and 1
        return jellyfish.jaro_distance(str1, str2)
    
    print("ERROR: Choose the right string similarity measure : LEV or JARO")
    

def get_match_score(ref1, ref2, level):
    ''' (dict, dict, string) --> double
    
    returns the similarity of reference 1 and 2 according to the level
    level 0 : no context
    level 1: profile context
    level 2: family context
    level 3: network context
    
    '''
    # if either person does not have any name, then score = 0 for any level
    if  (not ref1['first_name'] and not ref1['last_name']) or (not ref2['first_name'] and not ref2['last_name']):
        return 0
    
    if level == 0:
        score_first_name = string_compare (ref1['first_name'], ref2['first_name'])
        score_last_name = string_compare (ref1['last_name'], ref2['last_name'])
        return (score_first_name + score_last_name) / 2
    
    if level == 1:
        score_0 = get_match_score(ref1, ref2, 0)
        score_place = string_compare (ref1['place'], ref2['place'])
        
        if ref1['year'] and ref2['year']:
            score_year = (144.0 - abs(int(ref1['year']) - int(ref2['year'])) ) / 144.0 # score 1 for exact match and 0 for 144 years difference
        else: 
            score_year = 0
            
        # just in case of weird numbers
        if score_year > 1: score_year = 0
        if score_year < 0: score_year = 0

        return (score_0 * 2 + score_place + score_year) / 4
    
    if level == 2:
        score_1 = get_match_score(ref1, ref2, 1)        
        family_1 = get_family(ref1['id'])
        family_2 = get_family(ref2['id'])
        
        counter = 0
        score_family = 0
        for member_1 in family_1:
            for member_2 in family_2:
                score_family = score_family + get_match_score(get_person(member_1), get_person(member_2), 0)
                counter = counter + 1
        score_family = score_family / counter
        return (2 * score_1 + score_family) / 3
    
    print("ERROR: Choose the right context level from {0, 1, 2, 3}")

def row_to_reference(row, table = "all_persons"):
    ''' (list, table) -> (dict)
    adds labels to different elements of the list, according to the table type,
    and makes a reference
    '''
    
    if table == 'all_persons':
        ref = {}
        ref['id'] = row[0]
        ref['first_name'] = row[1]
        ref['last_name'] = row[3]
        ref['year'] = row[4][6:12]
        ref['place'] = row[5]
        return ref
    
def get_person(person_id = None):
    ''' (integer) -> (dict)
    return a person with the id
    '''
    global db
    # if no id then find a random person
    if person_id:
        cur = run_query(db, "select * from all_persons where id = " + str(person_id)) # fetch the person with the the random id
        reference = row_to_reference(cur.fetchone())
        return reference
    
    if not person_id:
        flag = False  # this flag is used to be sure we get a valid person (i.e., has at least name)
        while not flag:
            
            # generate a random number
            from random import randrange
            person_id = randrange(1,5244863)
            
            cur = run_query(db, "select * from all_persons where id = " + str(person_id)) # fetch the person with the the random id
            reference = row_to_reference(cur.fetchone())
            if reference['first_name'] or reference['last_name']:
                flag = True # if the person has name, then flag is toggled
        return reference

    
def get_family(person_id):
    ''' (integer) -> (list of integers)
    returns the id of any family member found for the person_id
    '''
    global db
    id_list = []
    query = "select id from all_persons where register_id = (select register_id from all_persons where id = " + str(person_id) + ") and id <> " + str(person_id) 
    cur = run_query(db, query) # fetch the person with the the random id
    for row in cur.fetchall():
        id_list.append(row[0])
    return id_list

def count_islands(level):
    '''(int) -> (int)
    returns number of islands left after the matching of requested level  
   
    level 0: no context
    level 1: profile context
    level 2: family context
    level 3: network context
    '''
    if level == 0:
        query = 'Select count(*) from all_documents'
        cur = run_query(db, query) # fetch the person with the the random id
        return cur.fetchone()[0]
    

def add_blocking_code(blocking_type = 1):
    '''(int) -> ()
    adds new potential matches according to the blocking technique to the carr_match table.
    
    blocking_type 1: metaphone of last name
    '''
    global db
    if blocking_type == 1:
        import jellyfish
        count = 0
        query = 'Select id, last_name from all_persons'
        cur1 = run_query(db, query) # fetch the person with the the random id

        ref_list = []
        for row in cur1.fetchall(): 
            ref_list.append([row[0],row[1]])
        cur1.close()
        query = ''
        for ref in ref_list:
            count += 1
            if count%10000 == 0:
                if query:
                    # print query 
                    cur = run_query(db, query)
                    cur.fetchall()
                    cur.close()
                    query = ''
            metaphone = jellyfish.metaphone(ref[1])
            query += 'update all_persons set metaphone = "' + metaphone + '" where id =' + str(ref[0]) + ';'
        if query:
            cur = run_query(db, query)
            cur.fetchall()
            cur.close()
            query = ''

def do_matching(level):
    ''' (int)->()
    does the matching on the whole database for specific level of context
    level 0 : no context
    level 1: profile context
    level 2: family context
    level 3: network context    
    '''
    
    import time    
    global db    

    query = 'SELECT distinct(metaphone) FROM links_based.all_persons'
    cur = run_query(db, query)
    metaphone_list = []
    for metaphone in cur.fetchall():
        metaphone_list.append(metaphone[0])
    # for parallel work, we pick a random metaphone, and do blocking that
    while True:
#    for metaphone in metaphone_list:
        from random import choice
        metaphone = choice(metaphone_list)
        query = 'select id from links_based.all_persons where metaphone = "' + metaphone + '"'
        cur = run_query(db, query)
        ref1_list = []
        ref2_list = []
        for reference in cur.fetchall():
            ref1_list.append(reference[0])
            ref2_list.append(reference[0])
        query = 'SELECT ref1, ref2, level FROM links_based.carr_match;'
        cur = run_query(db, query)
        match_list = []
        for match in cur.fetchall():
            match_list.append([match[0],match[1],match[2]])
        query = ''
        for ref1 in ref1_list:
            for ref2 in ref2_list:
                if ref1 < ref2:
                    if not [ref1, ref2, level] in match_list:
                        score = get_match_score(get_person(ref1), get_person(ref2), level)
                        date_time = time.strftime('%Y-%m-%d %H:%M:%S')
                        query += 'insert into carr_match (ref1,ref2,score,level, blocking, date) VALUES (' \
                                            + str(ref1) + ',' + str(ref2) + ',' + str(score) + ',' + str(level) \
                                            + ',"' + str(metaphone) + '","' + str(date_time) +'");'
            if query:
                #print query
                cur = run_query(db, query)
                cur.fetchall()
                cur.close()
                query = ''
        
        
if __name__ == '__main__':
    #db = do_connect()
    db = do_connect('SRV')
    do_matching(1);
#     print count_islands(0)
#     
#     ref1 = get_person()
#     ref2 = get_person()
#     
#     score_0 = context_matching(ref1, ref2, 0)
#     print ref1,'\n', ref2, '\n score_0 is ', score_0,  
#     score_1 = context_matching(ref1, ref2, 1)
#     print  ', score_1 is ', score_1, 
#     score_2 = context_matching(ref1, ref2, 2)
#     print ', and score_2 is', score_2 
#     
